### 两种方案
可以明显发现模拟滚动方式体验更好  
直接看代码可能无法发现两种方案存在性能差距的原因，对此我问了一下gpt：  


```html
mousemove事件的触发频率通常会高于屏幕的刷新率。而屏幕的刷新率是指屏幕每秒更新显示内容的次数。

一般来说，mousemove事件在鼠标指针在页面上移动时触发。具体的触发频率取决于多个因素，包括浏览器、设备性能和当前页面的复杂性。

在较新的浏览器和设备上，mousemove事件可以以非常高的频率触发，达到每秒数百次甚至更高。这是因为浏览器会尽力捕捉鼠标指针的每个微小移动，以提供更精细的交互体验。

与此相比，屏幕的刷新率通常介于 60Hz 到 144Hz 之间，也就是每秒 60 到 144 帧。屏幕每秒只更新指定次数的显示内容。

因此，mousemove事件的触发频率通常会远高于屏幕的刷新率。这也意味着在处理mousemove事件时，你可能会获得比屏幕刷新率更高的精度和频率，但同时需要注意性能开销，避免不必要的计算和操作。
```

```html
在一般情况下，scroll事件的触发频率通常与屏幕的刷新率（屏幕的帧率）相关。屏幕的刷新率是指屏幕每秒更新显示内容的次数，通常以帧（Frame）每秒（FPS）为单位表示。

常见的屏幕刷新率包括 60Hz、75Hz、120Hz、144Hz 等。这意味着屏幕每秒刷新 60 次、75 次、120 次、144 次等。

对于大多数情况而言，scroll事件的触发频率通常与屏幕的刷新率相同或略低于屏幕的刷新率。这是因为浏览器会在屏幕刷新时检测滚动位置，并在需要时触发scroll事件。

例如，如果屏幕的刷新率为 60Hz，则在一般情况下，scroll事件的触发频率可能在 60 FPS 左右或略低于 60 FPS。

需要注意的是，触发频率可能因具体的浏览器、设备性能和页面复杂性而有所差异。此外，某些浏览器可能对scroll事件进行节流或合并，以避免过多的事件处理。
```

当然，其实gpt也没有给出确切结论，到现在我也不知道具体怎么回事，这是gpt的另一个说法

```html
白屏问题可能出现的原因之一是浏览器的渲染机制决定了渲染和响应滚动事件的优先级。浏览器可能优先处理滚动事件，而将页面的渲染放在较低的优先级。当快速滚动页面时，滚动事件的触发频率可能非常高，导致浏览器过多地处理滚动事件而无法及时完成页面的渲染，因此出现白屏的情况。
```

在这里我也询问了一下其它写过虚拟滚动库的作者，下面的回复来自一个虚拟滚动插件的作者
他的博客地址是 https://free_pan.gitee.io/freepan-blog
  
  ```html
  测试
  在cpu进行四倍降速或者六倍降速的情况下，模拟滚动方案的滑块开始明显卡顿。

  关于白屏
  在cpu未限制的情况下，模拟滚动条不白屏，可能以当前cpu计算能力足以应对，所以没差异，也没白屏。
  在cpu有限制的情况下，直接拖动滑块的化，模拟滚动条的方案已经卡了。
  白屏是因为滚动没阻塞，已经滚动到了正确位置，并清除了滚动前的内容，但还没渲染出滚动后的内容。
  而模拟滚动的滚动已经卡住了，可能这就是模拟滚动没白屏的原因
```

如果有朋友了解这些，可以浇一浇。

